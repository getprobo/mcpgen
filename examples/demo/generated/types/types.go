// Code generated by mcpgen. DO NOT EDIT.

package types

import (
	"encoding/json"
	"fmt"
	"go.probo.inc/mcpgen/pkg/mcputil"
	"time"
)

// Tool input schemas
var (
	Calculate2ToolInputSchema  = mcputil.MustUnmarshalSchema(`{"type":"object","required":["title","priority"],"properties":{"completed":{"type":"boolean","description":"Whether task is completed"},"deadline":{"type":"string","description":"Task deadline","format":"date-time"},"priority":{"type":"string","description":"Task priority level","enum":["low","medium","high","urgent"]},"tags":{"type":"array","description":"Task tags","items":{"type":"string"}},"title":{"type":"string","description":"Task title"}}}`)
	CreateTaskToolInputSchema  = mcputil.MustUnmarshalSchema(`{"type":"object","required":["title","priority"],"properties":{"completed":{"type":"boolean","description":"Whether task is completed"},"deadline":{"type":"string","description":"Task deadline","format":"date-time"},"priority":{"type":"string","description":"Task priority level","enum":["low","medium","high","urgent"]},"tags":{"type":"array","description":"Task tags","items":{"type":"string"}},"title":{"type":"string","description":"Task title"}}}`)
	CreateTaskToolOutputSchema = mcputil.MustUnmarshalSchema(`{"type":"object","properties":{"createdAt":{"type":"string","description":"Creation timestamp","format":"date-time"},"id":{"type":"string","description":"Task ID"},"priority":{"type":"string","description":"Priority level","enum":["low","medium","high","urgent"]},"status":{"type":"string","description":"Task status","enum":["pending","in_progress","completed","cancelled"]},"title":{"type":"string","description":"Task title"}}}`)
	SearchToolInputSchema      = mcputil.MustUnmarshalSchema(`{"type":"object","required":["query"],"properties":{"filter":{"type":"string","description":"Filter results","enum":["all","active","completed"]},"limit":{"type":"integer","description":"Maximum number of results","default":10},"query":{"type":"string","description":"Search query"}}}`)
	GetHistoryToolInputSchema  = mcputil.MustUnmarshalSchema(`{"type":"object","properties":{"limit":{"type":"integer","description":"Maximum number of history entries","default":10}}}`)
	CalculateToolInputSchema   = mcputil.MustUnmarshalSchema(`{"type":"object","required":["operation","a","b"],"properties":{"a":{"type":"number","description":"First operand"},"b":{"type":"number","description":"Second operand"},"operation":{"type":"string","description":"The arithmetic operation to perform","enum":["add","subtract","multiply","divide"]}}}`)
	CalculateToolOutputSchema  = mcputil.MustUnmarshalSchema(`{"type":"object","properties":{"operation":{"type":"string","description":"The operation that was performed"},"value":{"type":"number","description":"The result value"}}}`)
)

// The arithmetic operation to perform
type Operation string

const (
	OperationAdd      Operation = "add"
	OperationSubtract Operation = "subtract"
	OperationMultiply Operation = "multiply"
	OperationDivide   Operation = "divide"
)

// IsValid returns true if the Operation value is valid
func (e Operation) IsValid() bool {
	switch e {
	case OperationAdd:
		return true
	case OperationSubtract:
		return true
	case OperationMultiply:
		return true
	case OperationDivide:
		return true
	}
	return false
}

// UnmarshalJSON implements json.Unmarshaler
func (e *Operation) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	*e = Operation(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid Operation value: %q", s)
	}
	return nil
}

// MarshalJSON implements json.Marshaler
func (e Operation) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid Operation value: %q", string(e))
	}
	return json.Marshal(string(e))
}

// Task status
type Status string

const (
	StatusPending    Status = "pending"
	StatusInProgress Status = "in_progress"
	StatusCompleted  Status = "completed"
	StatusCancelled  Status = "cancelled"
)

// IsValid returns true if the Status value is valid
func (e Status) IsValid() bool {
	switch e {
	case StatusPending:
		return true
	case StatusInProgress:
		return true
	case StatusCompleted:
		return true
	case StatusCancelled:
		return true
	}
	return false
}

// UnmarshalJSON implements json.Unmarshaler
func (e *Status) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	*e = Status(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid Status value: %q", s)
	}
	return nil
}

// MarshalJSON implements json.Marshaler
func (e Status) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid Status value: %q", string(e))
	}
	return json.Marshal(string(e))
}

// Priority level
type Priority string

const (
	PriorityLow    Priority = "low"
	PriorityMedium Priority = "medium"
	PriorityHigh   Priority = "high"
	PriorityUrgent Priority = "urgent"
)

// IsValid returns true if the Priority value is valid
func (e Priority) IsValid() bool {
	switch e {
	case PriorityLow:
		return true
	case PriorityMedium:
		return true
	case PriorityHigh:
		return true
	case PriorityUrgent:
		return true
	}
	return false
}

// UnmarshalJSON implements json.Unmarshaler
func (e *Priority) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	*e = Priority(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid Priority value: %q", s)
	}
	return nil
}

// MarshalJSON implements json.Marshaler
func (e Priority) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid Priority value: %q", string(e))
	}
	return json.Marshal(string(e))
}

// Filter results
type Filter string

const (
	FilterAll       Filter = "all"
	FilterActive    Filter = "active"
	FilterCompleted Filter = "completed"
)

// IsValid returns true if the Filter value is valid
func (e Filter) IsValid() bool {
	switch e {
	case FilterAll:
		return true
	case FilterActive:
		return true
	case FilterCompleted:
		return true
	}
	return false
}

// UnmarshalJSON implements json.Unmarshaler
func (e *Filter) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	*e = Filter(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid Filter value: %q", s)
	}
	return nil
}

// MarshalJSON implements json.Marshaler
func (e Filter) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid Filter value: %q", string(e))
	}
	return json.Marshal(string(e))
}

// TaskDetailsContent represents the schema
type TaskDetailsContent struct {
	// Priority level
	Priority Priority `json:"priority,omitempty"`
	// Task status
	Status Status `json:"status,omitempty"`
	// Task title
	Title string `json:"title,omitempty"`
	// Creation timestamp
	CreatedAt time.Time `json:"createdAt,omitempty"`
	// Task ID
	ID string `json:"id,omitempty"`
}

// Calculate2Input represents the schema
type Calculate2Input struct {
	// Task tags
	Tags []string `json:"tags,omitempty"`
	// Task title
	Title string `json:"title"`
	// Whether task is completed
	Completed bool `json:"completed,omitempty"`
	// Task deadline
	Deadline time.Time `json:"deadline,omitempty"`
	// Task priority level
	Priority Priority `json:"priority"`
}

// CreateTaskInput represents the schema
type CreateTaskInput struct {
	// Whether task is completed
	Completed bool `json:"completed,omitempty"`
	// Task deadline
	Deadline time.Time `json:"deadline,omitempty"`
	// Task priority level
	Priority Priority `json:"priority"`
	// Task tags
	Tags []string `json:"tags,omitempty"`
	// Task title
	Title string `json:"title"`
}

// GetHistoryInput represents the schema
type GetHistoryInput struct {
	// Maximum number of history entries
	Limit int64 `json:"limit,omitempty"`
}

// LastResultContent represents the schema
type LastResultContent struct {
	// The operation that was performed
	Operation string `json:"operation,omitempty"`
	// The result value
	Value float64 `json:"value,omitempty"`
}

// TaskHelpArgs represents the schema
type TaskHelpArgs struct {
	// The help topic (tasks, priorities, etc)
	Topic string `json:"topic,omitempty"`
	// Whether to show detailed help
	Detailed string `json:"detailed,omitempty"`
}

// MathHelpArgs represents the schema
type MathHelpArgs struct {
	// The operation to get help with
	Operation string `json:"operation,omitempty"`
}

// CalculateInput represents the schema
type CalculateInput struct {
	// Second operand
	B float64 `json:"b"`
	// The arithmetic operation to perform
	Operation Operation `json:"operation"`
	// First operand
	A float64 `json:"a"`
}

// Result represents the schema
type Result struct {
	// The operation that was performed
	Operation string `json:"operation,omitempty"`
	// The result value
	Value float64 `json:"value,omitempty"`
}

// TaskDetails represents the schema
type TaskDetails struct {
	// Task status
	Status Status `json:"status,omitempty"`
	// Task title
	Title string `json:"title,omitempty"`
	// Creation timestamp
	CreatedAt time.Time `json:"createdAt,omitempty"`
	// Task ID
	ID string `json:"id,omitempty"`
	// Priority level
	Priority Priority `json:"priority,omitempty"`
}

// TaskInput represents the schema
type TaskInput struct {
	// Whether task is completed
	Completed bool `json:"completed,omitempty"`
	// Task deadline
	Deadline time.Time `json:"deadline,omitempty"`
	// Task priority level
	Priority Priority `json:"priority"`
	// Task tags
	Tags []string `json:"tags,omitempty"`
	// Task title
	Title string `json:"title"`
}

// CalculateOutput represents the schema
type CalculateOutput struct {
	// The result value
	Value float64 `json:"value,omitempty"`
	// The operation that was performed
	Operation string `json:"operation,omitempty"`
}

// CreateTaskOutput represents the schema
type CreateTaskOutput struct {
	// Task ID
	ID string `json:"id,omitempty"`
	// Priority level
	Priority Priority `json:"priority,omitempty"`
	// Task status
	Status Status `json:"status,omitempty"`
	// Task title
	Title string `json:"title,omitempty"`
	// Creation timestamp
	CreatedAt time.Time `json:"createdAt,omitempty"`
}

// SearchInput represents the schema
type SearchInput struct {
	// Filter results
	Filter Filter `json:"filter,omitempty"`
	// Maximum number of results
	Limit int64 `json:"limit,omitempty"`
	// Search query
	Query string `json:"query"`
}
