package codegen

import (
	"fmt"
	"go/format"
	"sort"
	"strings"

	"go.probo.inc/mcpgen/internal/schema"
)

type CustomTypeMapping struct {
	GoType     string
	ImportPath string
	IsPointer  bool
}

type TypeGenerator struct {
	schemas        map[string]*schema.Schema
	types          map[string]string
	enums          map[string]string
	imports        map[string]bool
	schemaVars     map[string]string
	customMappings map[string]*CustomTypeMapping
}

func NewTypeGenerator() *TypeGenerator {
	return &TypeGenerator{
		schemas:        make(map[string]*schema.Schema),
		types:          make(map[string]string),
		enums:          make(map[string]string),
		imports:        make(map[string]bool),
		schemaVars:     make(map[string]string),
		customMappings: make(map[string]*CustomTypeMapping),
	}
}

func (g *TypeGenerator) AddCustomMapping(schemaName string, mapping *CustomTypeMapping) {
	g.customMappings[schemaName] = mapping
}

func (g *TypeGenerator) AddSchema(name string, s *schema.Schema) {
	g.schemas[name] = s
}

func (g *TypeGenerator) AddSchemaVar(name string, schemaJSON string) {
	g.schemaVars[name] = schemaJSON
	g.imports["go.probo.inc/mcpgen/mcp"] = true
}

func (g *TypeGenerator) Generate(packageName string) ([]byte, error) {
	var buf strings.Builder

	buf.WriteString("// Code generated by mcpgen. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	// Sort schema names for deterministic output
	schemaNames := make([]string, 0, len(g.schemas))
	for name := range g.schemas {
		schemaNames = append(schemaNames, name)
	}
	sort.Strings(schemaNames)

	for _, name := range schemaNames {
		s := g.schemas[name]
		typeName := toGoTypeName(name)

		if _, hasCustomMapping := g.customMappings[name]; hasCustomMapping {
			continue
		}

		typeCode, err := g.generateType(typeName, s, 0)
		if err != nil {
			return nil, fmt.Errorf("failed to generate type for %s: %w", name, err)
		}

		if typeCode != "" && g.types[typeName] == "" {
			g.types[typeName] = typeCode
		}
	}

	if len(g.imports) > 0 {
		buf.WriteString("import (\n")
		// Sort imports for deterministic output
		imports := make([]string, 0, len(g.imports))
		for imp := range g.imports {
			imports = append(imports, imp)
		}
		sort.Strings(imports)
		for _, imp := range imports {
			buf.WriteString(fmt.Sprintf("\t\"%s\"\n", imp))
		}
		buf.WriteString(")\n\n")
	}

	if len(g.schemaVars) > 0 {
		buf.WriteString("// Tool input schemas\n")
		buf.WriteString("var (\n")
		// Sort schema var names for deterministic output
		varNames := make([]string, 0, len(g.schemaVars))
		for varName := range g.schemaVars {
			varNames = append(varNames, varName)
		}
		sort.Strings(varNames)
		for _, varName := range varNames {
			schemaJSON := g.schemaVars[varName]
			buf.WriteString(fmt.Sprintf("\t%s = mcp.MustUnmarshalSchema(`%s`)\n", varName, schemaJSON))
		}
		buf.WriteString(")\n\n")
	}

	// Sort enum names for deterministic output
	enumNames := make([]string, 0, len(g.enums))
	for enumName := range g.enums {
		enumNames = append(enumNames, enumName)
	}
	sort.Strings(enumNames)
	for _, enumName := range enumNames {
		enumCode := g.enums[enumName]
		buf.WriteString(enumCode)
		buf.WriteString("\n\n")
	}

	written := make(map[string]bool)

	// Sort schema names for deterministic output (second pass)
	for _, name := range schemaNames {
		typeName := toGoTypeName(name)
		if typeCode := g.types[typeName]; typeCode != "" {
			buf.WriteString(typeCode)
			buf.WriteString("\n\n")
			written[typeName] = true
		}
	}

	// Sort type names for deterministic output
	typeNames := make([]string, 0, len(g.types))
	for typeName := range g.types {
		typeNames = append(typeNames, typeName)
	}
	sort.Strings(typeNames)
	for _, typeName := range typeNames {
		typeCode := g.types[typeName]
		if !written[typeName] && typeCode != "" {
			buf.WriteString(typeCode)
			buf.WriteString("\n\n")
		}
	}

	formatted, err := format.Source([]byte(buf.String()))
	if err != nil {
		return nil, fmt.Errorf("failed to format generated code: %w\n%s", err, buf.String())
	}

	return formatted, nil
}

func (g *TypeGenerator) generateType(name string, s *schema.Schema, depth int) (string, error) {
	schemaType := schema.GetType(s)

	if schemaType == "" && s.Properties != nil && len(s.Properties) > 0 {
		return g.generateStruct(name, s, depth)
	}

	if schemaType == "" && s.Properties == nil {
		return "", fmt.Errorf("unsupported schema type: %q (no type and no properties for %s)", schemaType, name)
	}

	if len(s.Enum) > 0 {
		return g.generateEnum(name, s)
	}

	switch schemaType {
	case "object":
		return g.generateStruct(name, s, depth)
	case "array":
		return g.generateArrayType(name, s, depth)
	case "string":
		if depth == 0 {
			return g.generatePrimitiveTypeAlias(name, s, "string")
		}
		return "", nil
	case "number":
		if depth == 0 {
			return g.generatePrimitiveTypeAlias(name, s, "float64")
		}
		return "", nil
	case "integer":
		if depth == 0 {
			return g.generatePrimitiveTypeAlias(name, s, "int")
		}
		return "", nil
	case "boolean":
		if depth == 0 {
			return g.generatePrimitiveTypeAlias(name, s, "bool")
		}
		return "", nil
	default:
		if len(s.Properties) > 0 {
			return g.generateStruct(name, s, depth)
		}
		return "", fmt.Errorf("unsupported schema type: %s", schemaType)
	}
}

func (g *TypeGenerator) generateStruct(name string, s *schema.Schema, depth int) (string, error) {
	var buf strings.Builder

	if s.Description != "" {
		buf.WriteString(formatComment(s.Description, ""))
	} else if s.Title != "" {
		buf.WriteString(formatComment(s.Title, ""))
	} else {
		buf.WriteString(fmt.Sprintf("// %s represents the schema\n", name))
	}

	buf.WriteString(fmt.Sprintf("type %s struct {\n", name))

	// Sort property names for deterministic output
	propNames := make([]string, 0, len(s.Properties))
	for propName := range s.Properties {
		propNames = append(propNames, propName)
	}
	sort.Strings(propNames)

	for _, propName := range propNames {
		propSchema := s.Properties[propName]
		fieldName := toGoFieldName(propName)
		hint := name + fieldName

		isRequired := schema.IsRequired(s, propName)
		isOmittable := schema.IsOmittable(propSchema)

		// Validate that omittable is only used on nullable fields
		if isOmittable {
			isNullable, _ := isNullableType(propSchema)
			if !isNullable {
				return "", fmt.Errorf("field %s.%s has omittable annotation but is not nullable (omittable only works with nullable fields)", name, propName)
			}
		}

		fieldType, err := g.goType(propSchema, hint)
		if err != nil {
			return "", fmt.Errorf("failed to generate field %s: %w", propName, err)
		}

		if isOmittable {
			fieldType = fmt.Sprintf("mcp.Omittable[%s]", fieldType)
			g.imports["go.probo.inc/mcpgen/mcp"] = true
		} else if !isRequired && !isPointerType(fieldType) {
			fieldType = "*" + fieldType
		}

		if propSchema.Description != "" {
			buf.WriteString(formatComment(propSchema.Description, "\t"))
		}

		buf.WriteString(fmt.Sprintf("\t%s %s", fieldName, fieldType))

		jsonTag := propName
		if !isRequired {
			jsonTag += ",omitempty"
		}
		buf.WriteString(fmt.Sprintf(" `json:\"%s\"`", jsonTag))

		buf.WriteString("\n")
	}

	buf.WriteString("}")

	return buf.String(), nil
}

// isPointerType checks if the given type string is already a pointer or slice type
func isPointerType(t string) bool {
	return len(t) > 0 && (t[0] == '*' || t[0] == '[')
}

func isNullableType(s *schema.Schema) (bool, *schema.Schema) {
	if len(s.AnyOf) == 2 {
		var nullIndex = -1
		var typeIndex = -1

		for i, subSchema := range s.AnyOf {
			subType := schema.GetType(subSchema)
			if subType == "null" {
				nullIndex = i
			} else if subType != "" || subSchema.Properties != nil || subSchema.Ref != "" {
				typeIndex = i
			}
		}

		if nullIndex >= 0 && typeIndex >= 0 {
			return true, s.AnyOf[typeIndex]
		}
	}

	if len(s.Types) > 0 {
		hasNull := false
		var otherType string
		for _, t := range s.Types {
			if t == "null" {
				hasNull = true
			} else if otherType == "" {
				otherType = t
			}
		}

		if hasNull && otherType != "" && len(s.Types) == 2 {
			syntheticSchema := &schema.Schema{
				Type:   otherType,
				Format: s.Format,
			}
			return true, syntheticSchema
		}
	}

	return false, nil
}

func (g *TypeGenerator) generateArrayType(name string, s *schema.Schema, depth int) (string, error) {
	if s.Items == nil {
		if depth == 0 {
			return g.generatePrimitiveTypeAlias(name, s, "[]any")
		}
		return "[]any", nil
	}

	itemType, err := g.goType(s.Items, name+"Item")
	if err != nil {
		return "", err
	}

	arrayType := fmt.Sprintf("[]%s", itemType)

	if depth == 0 {
		return g.generatePrimitiveTypeAlias(name, s, arrayType)
	}

	return arrayType, nil
}

func (g *TypeGenerator) goType(s *schema.Schema, hint string) (string, error) {
	if s.Ref != "" {
		const prefix = "#/components/schemas/"
		if len(s.Ref) > len(prefix) && s.Ref[:len(prefix)] == prefix {
			schemaName := s.Ref[len(prefix):]

			if customMapping, ok := g.customMappings[schemaName]; ok {
				if customMapping.ImportPath != "" {
					g.imports[customMapping.ImportPath] = true
				}
				if customMapping.IsPointer {
					return "*" + customMapping.GoType, nil
				}
				return customMapping.GoType, nil
			}

			return "*" + toGoTypeName(schemaName), nil
		}
	}

	if nullable, baseType := isNullableType(s); nullable {
		goType, err := g.goType(baseType, hint)
		if err != nil {
			return "", err
		}
		if len(goType) > 0 && goType[0] == '*' {
			return goType, nil
		}
		return "*" + goType, nil
	}

	schemaType := schema.GetType(s)

	switch schemaType {
	case "string":
		if len(s.Enum) > 0 {
			enumTypeName := toGoTypeName(hint)
			if g.enums[enumTypeName] == "" {
				enumCode, err := g.generateEnum(enumTypeName, s)
				if err != nil {
					return "", err
				}
				g.enums[enumTypeName] = enumCode
			}
			return enumTypeName, nil
		}
		return g.goStringType(s), nil
	case "number":
		return "float64", nil
	case "integer":
		return "int64", nil
	case "boolean":
		return "bool", nil
	case "array":
		if s.Items == nil {
			return "[]any", nil
		}
		itemType, err := g.goType(s.Items, hint+"Item")
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("[]%s", itemType), nil
	case "object":
		if s.Title != "" {
			typeName := toGoTypeName(s.Title)
			if g.types[typeName] == "" {
				typeCode, err := g.generateStruct(typeName, s, 0)
				if err != nil {
					return "", err
				}
				g.types[typeName] = typeCode
			}
			return typeName, nil
		}
		if len(s.Properties) > 0 {
			typeName := hint
			if g.types[typeName] == "" {
				typeCode, err := g.generateStruct(typeName, s, 0)
				if err != nil {
					return "", err
				}
				g.types[typeName] = typeCode
			}
			return typeName, nil
		}
		return "map[string]any", nil
	case "null":
		return "any", nil
	default:
		if len(s.Properties) > 0 {
			typeName := toGoTypeName(hint)
			if g.types[typeName] == "" {
				typeCode, err := g.generateStruct(typeName, s, 0)
				if err != nil {
					return "", err
				}
				g.types[typeName] = typeCode
			}
			return typeName, nil
		}
		return "any", nil
	}
}

func (g *TypeGenerator) generatePrimitiveTypeAlias(name string, s *schema.Schema, goType string) (string, error) {
	var buf strings.Builder

	if s.Description != "" {
		buf.WriteString(formatComment(s.Description, ""))
	} else {
		buf.WriteString(fmt.Sprintf("// %s represents a %s schema\n", name, goType))
	}

	buf.WriteString(fmt.Sprintf("type %s %s", name, goType))
	return buf.String(), nil
}

func (g *TypeGenerator) generateEnum(enumTypeName string, s *schema.Schema) (string, error) {
	if len(s.Enum) == 0 {
		return "", fmt.Errorf("schema has no enum values")
	}

	var buf strings.Builder

	if s.Description != "" {
		buf.WriteString(formatComment(s.Description, ""))
	} else {
		buf.WriteString(fmt.Sprintf("// %s represents an enumeration\n", enumTypeName))
	}

	buf.WriteString(fmt.Sprintf("type %s string\n\n", enumTypeName))

	buf.WriteString("const (\n")
	var enumValues []string
	for i, enumValue := range s.Enum {
		strValue := fmt.Sprintf("%v", enumValue)
		enumValues = append(enumValues, strValue)
		constName := toEnumConstName(enumTypeName, strValue)

		if i == 0 {
			buf.WriteString(fmt.Sprintf("\t%s %s = %q\n", constName, enumTypeName, strValue))
		} else {
			buf.WriteString(fmt.Sprintf("\t%s %s = %q\n", constName, enumTypeName, strValue))
		}
	}
	buf.WriteString(")\n\n")

	// Generate validation method
	buf.WriteString(fmt.Sprintf("// IsValid returns true if the %s value is valid\n", enumTypeName))
	buf.WriteString(fmt.Sprintf("func (e %s) IsValid() bool {\n", enumTypeName))
	buf.WriteString("\tswitch e {\n")
	for _, strValue := range enumValues {
		constName := toEnumConstName(enumTypeName, strValue)
		buf.WriteString(fmt.Sprintf("\tcase %s:\n\t\treturn true\n", constName))
	}
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn false\n")
	buf.WriteString("}\n\n")

	// Generate UnmarshalJSON method
	buf.WriteString("// UnmarshalJSON implements json.Unmarshaler\n")
	buf.WriteString(fmt.Sprintf("func (e *%s) UnmarshalJSON(data []byte) error {\n", enumTypeName))
	buf.WriteString("\tvar s string\n")
	buf.WriteString("\tif err := json.Unmarshal(data, &s); err != nil {\n")
	buf.WriteString("\t\treturn err\n")
	buf.WriteString("\t}\n")
	buf.WriteString(fmt.Sprintf("\t*e = %s(s)\n", enumTypeName))
	buf.WriteString("\tif !e.IsValid() {\n")
	buf.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"invalid %s value: %%q\", s)\n", enumTypeName))
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn nil\n")
	buf.WriteString("}\n\n")

	// Generate MarshalJSON method
	buf.WriteString("// MarshalJSON implements json.Marshaler\n")
	buf.WriteString(fmt.Sprintf("func (e %s) MarshalJSON() ([]byte, error) {\n", enumTypeName))
	buf.WriteString("\tif !e.IsValid() {\n")
	buf.WriteString(fmt.Sprintf("\t\treturn nil, fmt.Errorf(\"invalid %s value: %%q\", string(e))\n", enumTypeName))
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn json.Marshal(string(e))\n")
	buf.WriteString("}")

	g.imports["encoding/json"] = true
	g.imports["fmt"] = true

	return buf.String(), nil
}

func (g *TypeGenerator) goStringType(s *schema.Schema) string {
	switch s.Format {
	case "date-time":
		g.imports["time"] = true
		return "time.Time"
	case "date", "time", "email", "hostname", "ipv4", "ipv6", "uri", "uuid":
		return "string"
	default:
		return "string"
	}
}

func toGoTypeName(name string) string {
	name = strings.TrimSuffix(name, ".json")
	name = strings.TrimSuffix(name, "_input")
	name = strings.TrimSuffix(name, "_output")
	name = strings.TrimSuffix(name, "_schema")

	parts := strings.FieldsFunc(name, func(r rune) bool {
		return r == '_' || r == '-' || r == ' ' || r == '.'
	})

	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}

	return strings.Join(parts, "")
}

var goAcronyms = map[string]bool{
	"acl":   true,
	"api":   true,
	"ascii": true,
	"cpu":   true,
	"css":   true,
	"dns":   true,
	"eof":   true,
	"guid":  true,
	"html":  true,
	"http":  true,
	"https": true,
	"id":    true,
	"ip":    true,
	"json":  true,
	"jwt":   true,
	"lhs":   true,
	"qps":   true,
	"ram":   true,
	"rhs":   true,
	"rpc":   true,
	"sla":   true,
	"smtp":  true,
	"sql":   true,
	"ssh":   true,
	"tcp":   true,
	"tls":   true,
	"ttl":   true,
	"udp":   true,
	"ui":    true,
	"uid":   true,
	"uri":   true,
	"url":   true,
	"utf":   true,
	"uuid":  true,
	"vm":    true,
	"xml":   true,
}

var goSpecialCase = map[string]string{
	"oauth": "OAuth",
}

func toGoFieldName(name string) string {
	parts := strings.FieldsFunc(name, func(r rune) bool {
		return r == '_' || r == '-' || r == ' '
	})

	for i, part := range parts {
		if len(part) > 0 {
			lowerPart := strings.ToLower(part)
			if specialCase, ok := goSpecialCase[lowerPart]; ok {
				parts[i] = specialCase
			} else if goAcronyms[lowerPart] {
				parts[i] = strings.ToUpper(part)
			} else {
				parts[i] = strings.ToUpper(part[:1]) + part[1:]
			}
		}
	}

	return strings.Join(parts, "")
}

func formatComment(text, prefix string) string {
	lines := strings.Split(strings.TrimSpace(text), "\n")
	var result strings.Builder

	for _, line := range lines {
		result.WriteString(fmt.Sprintf("%s// %s\n", prefix, strings.TrimSpace(line)))
	}

	return result.String()
}

func toEnumConstName(enumTypeName, value string) string {
	parts := strings.FieldsFunc(value, func(r rune) bool {
		return r == '_' || r == '-' || r == ' ' || r == '.'
	})

	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}

	constName := strings.Join(parts, "")
	baseName := strings.TrimSuffix(enumTypeName, "Type")

	return baseName + constName
}
