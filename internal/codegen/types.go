package codegen

import (
	"fmt"
	"go/format"
	"strings"

	"go.probo.inc/mcpgen/internal/schema"
)

type CustomTypeMapping struct {
	GoType     string
	ImportPath string
	IsPointer  bool
}

type TypeGenerator struct {
	schemas        map[string]*schema.Schema
	types          map[string]string
	enums          map[string]string
	imports        map[string]bool
	schemaVars     map[string]string
	customMappings map[string]*CustomTypeMapping
}

func NewTypeGenerator() *TypeGenerator {
	return &TypeGenerator{
		schemas:        make(map[string]*schema.Schema),
		types:          make(map[string]string),
		enums:          make(map[string]string),
		imports:        make(map[string]bool),
		schemaVars:     make(map[string]string),
		customMappings: make(map[string]*CustomTypeMapping),
	}
}

func (g *TypeGenerator) AddCustomMapping(schemaName string, mapping *CustomTypeMapping) {
	g.customMappings[schemaName] = mapping
}

func (g *TypeGenerator) AddSchema(name string, s *schema.Schema) {
	g.schemas[name] = s
}

func (g *TypeGenerator) AddSchemaVar(name string, schemaJSON string) {
	g.schemaVars[name] = schemaJSON
	g.imports["go.probo.inc/mcpgen/pkg/mcputil"] = true
}

func (g *TypeGenerator) Generate(packageName string) ([]byte, error) {
	var buf strings.Builder

	buf.WriteString("// Code generated by mcpgen. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	for name, s := range g.schemas {
		typeName := toGoTypeName(name)

		if _, hasCustomMapping := g.customMappings[name]; hasCustomMapping {
			continue
		}

		typeCode, err := g.generateType(typeName, s, 0)
		if err != nil {
			return nil, fmt.Errorf("failed to generate type for %s: %w", name, err)
		}

		if typeCode != "" && g.types[typeName] == "" {
			g.types[typeName] = typeCode
		}
	}

	if len(g.imports) > 0 {
		buf.WriteString("import (\n")
		for imp := range g.imports {
			buf.WriteString(fmt.Sprintf("\t\"%s\"\n", imp))
		}
		buf.WriteString(")\n\n")
	}

	if len(g.schemaVars) > 0 {
		buf.WriteString("// Tool input schemas\n")
		buf.WriteString("var (\n")
		for varName, schemaJSON := range g.schemaVars {
			buf.WriteString(fmt.Sprintf("\t%s = mcputil.MustUnmarshalSchema(`%s`)\n", varName, schemaJSON))
		}
		buf.WriteString(")\n\n")
	}

	for _, enumCode := range g.enums {
		buf.WriteString(enumCode)
		buf.WriteString("\n\n")
	}

	for name := range g.schemas {
		typeName := toGoTypeName(name)
		if typeCode := g.types[typeName]; typeCode != "" {
			buf.WriteString(typeCode)
			buf.WriteString("\n\n")
		}
	}

	formatted, err := format.Source([]byte(buf.String()))
	if err != nil {
		return nil, fmt.Errorf("failed to format generated code: %w\n%s", err, buf.String())
	}

	return formatted, nil
}

func (g *TypeGenerator) generateType(name string, s *schema.Schema, depth int) (string, error) {
	schemaType := schema.GetType(s)

	if schemaType == "" && s.Properties != nil && len(s.Properties) > 0 {
		return g.generateStruct(name, s, depth)
	}

	if schemaType == "" && s.Properties == nil {
		return "", fmt.Errorf("unsupported schema type: %q (no type and no properties for %s)", schemaType, name)
	}

	if len(s.Enum) > 0 {
		return g.generateEnum(name, s)
	}

	switch schemaType {
	case "object":
		return g.generateStruct(name, s, depth)
	case "array":
		return g.generateArrayType(name, s, depth)
	case "string":
		if depth == 0 {
			return g.generatePrimitiveTypeAlias(name, s, "string")
		}
		return "", nil
	case "number":
		if depth == 0 {
			return g.generatePrimitiveTypeAlias(name, s, "float64")
		}
		return "", nil
	case "integer":
		if depth == 0 {
			return g.generatePrimitiveTypeAlias(name, s, "int")
		}
		return "", nil
	case "boolean":
		if depth == 0 {
			return g.generatePrimitiveTypeAlias(name, s, "bool")
		}
		return "", nil
	default:
		if len(s.Properties) > 0 {
			return g.generateStruct(name, s, depth)
		}
		return "", fmt.Errorf("unsupported schema type: %s", schemaType)
	}
}

func (g *TypeGenerator) generateStruct(name string, s *schema.Schema, depth int) (string, error) {
	var buf strings.Builder

	if s.Description != "" {
		buf.WriteString(formatComment(s.Description, ""))
	} else if s.Title != "" {
		buf.WriteString(formatComment(s.Title, ""))
	} else {
		buf.WriteString(fmt.Sprintf("// %s represents the schema\n", name))
	}

	buf.WriteString(fmt.Sprintf("type %s struct {\n", name))

	for propName, propSchema := range s.Properties {
		fieldName := toGoFieldName(propName)
		fieldType, err := g.goType(propSchema, fieldName)
		if err != nil {
			return "", fmt.Errorf("failed to generate field %s: %w", propName, err)
		}

		if propSchema.Description != "" {
			buf.WriteString(formatComment(propSchema.Description, "\t"))
		}

		buf.WriteString(fmt.Sprintf("\t%s %s", fieldName, fieldType))

		jsonTag := propName
		if !schema.IsRequired(s, propName) {
			jsonTag += ",omitempty"
		}
		buf.WriteString(fmt.Sprintf(" `json:\"%s\"`", jsonTag))

		buf.WriteString("\n")
	}

	buf.WriteString("}")

	return buf.String(), nil
}

func isNullableType(s *schema.Schema) (bool, *schema.Schema) {
	if len(s.AnyOf) == 2 {
		var nullIndex = -1
		var typeIndex = -1

		for i, subSchema := range s.AnyOf {
			subType := schema.GetType(subSchema)
			if subType == "null" {
				nullIndex = i
			} else if subType != "" || subSchema.Properties != nil || subSchema.Ref != "" {
				typeIndex = i
			}
		}

		if nullIndex >= 0 && typeIndex >= 0 {
			return true, s.AnyOf[typeIndex]
		}
	}

	if len(s.Types) > 0 {
		hasNull := false
		var otherType string
		for _, t := range s.Types {
			if t == "null" {
				hasNull = true
			} else if otherType == "" {
				otherType = t
			}
		}

		if hasNull && otherType != "" && len(s.Types) == 2 {
			syntheticSchema := &schema.Schema{Type: otherType}
			return true, syntheticSchema
		}
	}

	return false, nil
}

func (g *TypeGenerator) generateArrayType(name string, s *schema.Schema, depth int) (string, error) {
	if s.Items == nil {
		if depth == 0 {
			return g.generatePrimitiveTypeAlias(name, s, "[]interface{}")
		}
		return "[]interface{}", nil
	}

	itemType, err := g.goType(s.Items, name+"Item")
	if err != nil {
		return "", err
	}

	arrayType := fmt.Sprintf("[]%s", itemType)

	if depth == 0 {
		return g.generatePrimitiveTypeAlias(name, s, arrayType)
	}

	return arrayType, nil
}

func (g *TypeGenerator) goType(s *schema.Schema, hint string) (string, error) {
	if s.Ref != "" {
		const prefix = "#/components/schemas/"
		if len(s.Ref) > len(prefix) && s.Ref[:len(prefix)] == prefix {
			schemaName := s.Ref[len(prefix):]

			if customMapping, ok := g.customMappings[schemaName]; ok {
				if customMapping.ImportPath != "" {
					g.imports[customMapping.ImportPath] = true
				}
				if customMapping.IsPointer {
					return "*" + customMapping.GoType, nil
				}
				return customMapping.GoType, nil
			}

			return "*" + toGoTypeName(schemaName), nil
		}
	}

	if nullable, baseType := isNullableType(s); nullable {
		goType, err := g.goType(baseType, hint)
		if err != nil {
			return "", err
		}
		return "*" + goType, nil
	}

	schemaType := schema.GetType(s)

	switch schemaType {
	case "string":
		if len(s.Enum) > 0 {
			enumTypeName := toGoTypeName(hint)
			if g.enums[enumTypeName] == "" {
				enumCode, err := g.generateEnum(enumTypeName, s)
				if err != nil {
					return "", err
				}
				g.enums[enumTypeName] = enumCode
			}
			return enumTypeName, nil
		}
		return g.goStringType(s), nil
	case "number":
		return "float64", nil
	case "integer":
		return "int64", nil
	case "boolean":
		return "bool", nil
	case "array":
		if s.Items == nil {
			return "[]interface{}", nil
		}
		itemType, err := g.goType(s.Items, hint+"Item")
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("[]%s", itemType), nil
	case "object":
		if s.Title != "" {
			typeName := toGoTypeName(s.Title)
			if g.types[typeName] == "" {
				typeCode, err := g.generateStruct(typeName, s, 0)
				if err != nil {
					return "", err
				}
				g.types[typeName] = typeCode
			}
			return typeName, nil
		}
		return "map[string]interface{}", nil
	case "null":
		return "interface{}", nil
	default:
		if len(s.Properties) > 0 {
			typeName := toGoTypeName(hint)
			if g.types[typeName] == "" {
				typeCode, err := g.generateStruct(typeName, s, 0)
				if err != nil {
					return "", err
				}
				g.types[typeName] = typeCode
			}
			return typeName, nil
		}
		return "interface{}", nil
	}
}

func (g *TypeGenerator) generatePrimitiveTypeAlias(name string, s *schema.Schema, goType string) (string, error) {
	var buf strings.Builder

	if s.Description != "" {
		buf.WriteString(formatComment(s.Description, ""))
	} else {
		buf.WriteString(fmt.Sprintf("// %s represents a %s schema\n", name, goType))
	}

	buf.WriteString(fmt.Sprintf("type %s %s", name, goType))
	return buf.String(), nil
}

func (g *TypeGenerator) generateEnum(enumTypeName string, s *schema.Schema) (string, error) {
	if len(s.Enum) == 0 {
		return "", fmt.Errorf("schema has no enum values")
	}

	var buf strings.Builder

	if s.Description != "" {
		buf.WriteString(formatComment(s.Description, ""))
	} else {
		buf.WriteString(fmt.Sprintf("// %s represents an enumeration\n", enumTypeName))
	}

	buf.WriteString(fmt.Sprintf("type %s string\n\n", enumTypeName))

	buf.WriteString("const (\n")
	var enumValues []string
	for i, enumValue := range s.Enum {
		strValue := fmt.Sprintf("%v", enumValue)
		enumValues = append(enumValues, strValue)
		constName := toEnumConstName(enumTypeName, strValue)

		if i == 0 {
			buf.WriteString(fmt.Sprintf("\t%s %s = %q\n", constName, enumTypeName, strValue))
		} else {
			buf.WriteString(fmt.Sprintf("\t%s %s = %q\n", constName, enumTypeName, strValue))
		}
	}
	buf.WriteString(")\n\n")

	// Generate validation method
	buf.WriteString(fmt.Sprintf("// IsValid returns true if the %s value is valid\n", enumTypeName))
	buf.WriteString(fmt.Sprintf("func (e %s) IsValid() bool {\n", enumTypeName))
	buf.WriteString("\tswitch e {\n")
	for _, strValue := range enumValues {
		constName := toEnumConstName(enumTypeName, strValue)
		buf.WriteString(fmt.Sprintf("\tcase %s:\n\t\treturn true\n", constName))
	}
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn false\n")
	buf.WriteString("}\n\n")

	// Generate UnmarshalJSON method
	buf.WriteString("// UnmarshalJSON implements json.Unmarshaler\n")
	buf.WriteString(fmt.Sprintf("func (e *%s) UnmarshalJSON(data []byte) error {\n", enumTypeName))
	buf.WriteString("\tvar s string\n")
	buf.WriteString("\tif err := json.Unmarshal(data, &s); err != nil {\n")
	buf.WriteString("\t\treturn err\n")
	buf.WriteString("\t}\n")
	buf.WriteString(fmt.Sprintf("\t*e = %s(s)\n", enumTypeName))
	buf.WriteString("\tif !e.IsValid() {\n")
	buf.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"invalid %s value: %%q\", s)\n", enumTypeName))
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn nil\n")
	buf.WriteString("}\n\n")

	// Generate MarshalJSON method
	buf.WriteString("// MarshalJSON implements json.Marshaler\n")
	buf.WriteString(fmt.Sprintf("func (e %s) MarshalJSON() ([]byte, error) {\n", enumTypeName))
	buf.WriteString("\tif !e.IsValid() {\n")
	buf.WriteString(fmt.Sprintf("\t\treturn nil, fmt.Errorf(\"invalid %s value: %%q\", string(e))\n", enumTypeName))
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn json.Marshal(string(e))\n")
	buf.WriteString("}")

	g.imports["encoding/json"] = true
	g.imports["fmt"] = true

	return buf.String(), nil
}

func (g *TypeGenerator) goStringType(s *schema.Schema) string {
	switch s.Format {
	case "date-time":
		g.imports["time"] = true
		return "time.Time"
	case "date", "time", "email", "hostname", "ipv4", "ipv6", "uri", "uuid":
		return "string"
	default:
		return "string"
	}
}

func toGoTypeName(name string) string {
	name = strings.TrimSuffix(name, ".json")
	name = strings.TrimSuffix(name, "_input")
	name = strings.TrimSuffix(name, "_output")
	name = strings.TrimSuffix(name, "_schema")

	parts := strings.FieldsFunc(name, func(r rune) bool {
		return r == '_' || r == '-' || r == ' ' || r == '.'
	})

	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}

	return strings.Join(parts, "")
}

func toGoFieldName(name string) string {
	if name == "id" {
		return "ID"
	}
	if name == "url" {
		return "URL"
	}
	if name == "uri" {
		return "URI"
	}
	if name == "api" {
		return "API"
	}

	parts := strings.FieldsFunc(name, func(r rune) bool {
		return r == '_' || r == '-' || r == ' '
	})

	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}

	return strings.Join(parts, "")
}

func formatComment(text, prefix string) string {
	lines := strings.Split(strings.TrimSpace(text), "\n")
	var result strings.Builder

	for _, line := range lines {
		result.WriteString(fmt.Sprintf("%s// %s\n", prefix, strings.TrimSpace(line)))
	}

	return result.String()
}

func toEnumConstName(enumTypeName, value string) string {
	parts := strings.FieldsFunc(value, func(r rune) bool {
		return r == '_' || r == '-' || r == ' ' || r == '.'
	})

	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}

	constName := strings.Join(parts, "")
	baseName := strings.TrimSuffix(enumTypeName, "Type")

	return baseName + constName
}
